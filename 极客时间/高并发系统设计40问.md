## 一些知识点

#### 缓存穿透

- 缓存中没有查到数据，而不得不从后端系统（比如数据库）中查询，而后端系统中数据也不存在。这就造成不论查询多少次，缓存穿透永远存在。

- 缓存穿透的解决方案

  - 回填空值

    ```
    Object nullValue = new Object();
    try {
      Object valueFromDB = getFromDB(uid); //从数据库中查询数据
      if (valueFromDB == null) {
        cache.set(uid, nullValue, 10);   //如果从数据库中查询到空值，就把空值写入缓存，设置较短的超时时间
      } else {
        cache.set(uid, valueFromDB, 1000);
      }
    } catch(Exception e) {
      cache.set(uid, nullValue, 10);
    }
    ```

    这种方法存在的问题是，缓存中会存在大量的空值缓存，造成缓存存储空间的浪费。同时，当缓存存储空间被占满，可能会LRU淘汰掉有用的缓存数据。

  - 使用布隆过滤器（Boom Filter）

    - Boom Filter主要用来判断一个元素是否在一个集合中，它由一个二进制数据和一个hash算法组成。

      ![](https://tva1.sinaimg.cn/large/00831rSTly1gd8kusasrhj30vk0c0q41.jpg)

    - Boom Filter解决缓存穿透问题（用户查询场景为例）

      ![](https://tva1.sinaimg.cn/large/00831rSTly1gd8kyqa3imj30wk0icgni.jpg)

    - 布隆过滤器拥有极高的性能，无论是写入操作还是读取操作，时间复杂度都是 O(1) 是常量值。

    - 两个主要缺陷（hash算法碰撞的问题，不可避免）

      1. 它在判断元素是否在集合中时是有一定错误几率的，比如它会把不是集合中的元素判断为处在集合中

      2. 不支持删除元素

    - 使用上的建议

      1. 选择多个 Hash 函数计算多个 Hash 值，这样可以减少误判的几率
      2. 布隆过滤器会消耗一定的内存空间，所以在使用时需要评估你的业务场景下需要多大的内存，存储的成本是否可以接受（本质就是空间换时间的思想）

#### 缓存击穿

- 缓存击穿是指缓存中没有但数据库中有的数据（一般是热点数据缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。（缓存穿透是缓存和数据库中都没有数据）。
- 常见的解决方案
  - 热点key永不过期，不推荐。
  - 并发时，利用分布式锁，只有获得锁的请求才可以穿透到数据库修改数据并设置缓存，其他请求等待后从缓存中查询。
  - 在代码中控制在某一个热点缓存项失效之后启动一个后台线程，穿透到数据库，将数据加载到缓存中，在缓存未加载之前，所有访问这个缓存的请求都不再穿透而直接返回。解决思路跟第二点是一样的，只让一个线程来加载数据到缓存。

#### 缓存雪崩

- 缓存雪崩是指缓存大量失效，导致大量的请求都直接向数据库获取数据，造成数据库的压力。缓存大量失效的原因可能是缓存服务器宏机，或者大量Redis的键设置的过期时间相同。
- 常见的解决方案
  - 高可用部署，哨兵模式或者cluster模式。
  - 缓存数据过期时间随机设置，避免同一时间大量的key过期。